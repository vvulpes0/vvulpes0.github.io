<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="alternate" type="application/rss+xml" title="RSS"
      href="https://dakotahlambert.com/rss.xml">
<title>Dakotah Lambert</title>
<link rel="stylesheet" type="text/css" href="/main.css">
</head>
<body>
<label for="darklight" class="dark-mode-selector">
  <span id="dark">&#x1F315;|&#x1F506;<span>Swap dark/light</span></span
></label>
<input type="checkbox" id="darklight" name="darklight">
<div id="colorscheme">
<div id="main-content">
<header>
<h1>Dakotah Lambert</h1>
<p>collected musings</p>
</header>
<nav>
<h2>Contents</h2>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/PDF/cv.pdf">CV</a></li>
<li><a href="/#interests">Interests</a></li>
<li><a href="/#projects">Projects</a></li>
<li><a href="/#publications">Publications</a></li>
<li><a href="/#talks">Talks</a></li>
<li><a href="/blog.html">Blog</a></li>
</ul>
</nav>
<article>
<h2><a href="/blog/20241110.html">Foundations:
    The &lambda;-Calculus</a></h2>
<p class="date">2024 Nov 12 at 01:05</p>
<nav>
<h3>Post Contents</h3>
<ul>
<li><a href="#propositional-logic">Propositional Logic</a></li>
<li><a href="#natural-numbers">Natural Numbers</a></li>
<li><a href="#integers">Integers</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#directions">Directions</a></li>
</ul>
</nav>
<p>Many are familiar with the concept of the Turing machine,
the mathematical model of computation that gives us the phrase
&ldquo;Turing Complete&rdquo;.
A Turing machine is built of several parts:
a finite alphabet of symbols,
an infinite tape divided into cells marked by these symbols,
a read/write head that can modify the tape,
and a finite set of control states
that determine what should be written
and how the tape should be moved
depending on what is read.
Less familiar but much simpler
is the λ-calculus of Alonzo Church.
Equivalent in expressive power to the Turing machine,
the λ-calculus has only
the creation and application of single-argument functions.
</p>
<ul>
<li>An identifier 𝑥 is an expression representing a parameter</li>
<li>If 𝐸 is an expression and 𝑥 an identifier,
  then (λ𝑥.𝐸) is an expression
  representing a function.</li>
<li>If 𝐸 and 𝐹 are expressions,
  then (𝐸𝐹) is an expression representing the application
  of 𝐸 to 𝐹.</li>
<li>Nothing else is an expression.</li>
</ul>
<p>To improve readability by avoiding excessive parentheses,
function application is associated to the left:
𝑤𝑥𝑦𝑧&nbsp;≡&nbsp;(((𝑤𝑥)𝑦)𝑧).
Further, parentheses are omitted from functions
that are created but not applied:
λ𝑓.λ𝑥.λ𝑦.𝑓𝑦𝑥&nbsp;≡&nbsp;(λ𝑓.(λ𝑥.(λ𝑦.(𝑓𝑦)𝑥))),
distinct from
λ𝑓.λ𝑥.(λ𝑦.𝑓𝑦)𝑥&nbsp;≡&nbsp;(λ𝑓.(λ𝑥.(λ𝑦.(𝑓𝑦))𝑥)).
</p>
<p>Programs are built from data and transformations.
In a high-level language,
the job of a programmer is to define
the structure of relevant objects
and some sequence of valid transformations
to convert input states into desired output states.
This structure applies to all computational formalisms.
For a Turing machine,
objects must be encoded as some linear sequence of symbols on the tape.
For the λ-calculus,
objects must be encoded as some sort of single-argument function.
Here, we&rsquo;ll explore representations of some basic objects.
</p>

<h3 id="propositional-logic"><a href="#propositional-logic"
>Propositional Logic</a></h3>
<p>Arguably the simplest data structure is the humble Boolean,
with two distinct values: true and false.
How might one represent a Boolean value as a single-argument function?
To answer this, consider how Boolean values are used.
Typically, they are used in conditional expressions:
if some condition 𝐶 holds, then 𝑋, else 𝑌.
Instead of defining true and false as atomic values,
we can define them in terms of this conditional structure.
If 𝐶 is a Boolean value,
we can have 𝐶𝑋𝑌 produce 𝑋 when 𝐶 is true,
and produce 𝑌 when 𝐶 is false.
</p>
<p>This looks like we are considering two-argument functions,
but we need not take more than one at a time.
Let us define the Boolean value &ldquo;true&rdquo; as 𝐓.
We want 𝐓𝑋𝑌 to be 𝑋.
In other words, we want (𝐓𝑋)
to be a function of one argument which returns 𝑋
no matter its input:
𝐓&nbsp;≡&nbsp;λ𝑥.λ𝑦.𝑥.
In action:
𝐓𝑋𝑌&nbsp;≡&nbsp;(λ𝑥.λ𝑦.𝑥)𝑋𝑌&nbsp;≡&nbsp;(λ𝑦.𝑋)𝑌&nbsp;≡&nbsp;𝑋.
(This process of selecting an argument
and instantiating it inside the function body
is called β-reduction.)
Similarly, 𝐅 selects the second of the two arguments:
𝐅&nbsp;≡&nbsp;λ𝑥.λ𝑦.𝑦.
In action:
𝐅𝑋𝑌&nbsp;≡&nbsp;(λ𝑥.λ𝑦.𝑦)𝑋𝑌&nbsp;≡&nbsp;(λ𝑦.𝑦)𝑌&nbsp;≡&nbsp;𝑌.
</p>
<p>Boolean combinators such AND, OR and NOT,
are naturally two-argument functions.
First consider the OR combinator, which we will denote ∨.
Recall that Booleans are essentially
two-argument functions that represent if-then-else constructions.
It should be that ∨𝑃𝑄 is true if 𝑃 is true,
else it is true if 𝑄 is true and false otherwise.
In fully expanded form:
∨𝑃𝑄&nbsp;≡&nbsp;𝑃𝐓(𝑄𝐓𝐅).
Notice, however, that (𝑄𝐓𝐅) is equivalent to 𝑄:
if 𝑄&nbsp;≡&nbsp;𝐓 then 𝐓 is selected,
and if 𝑄&nbsp;≡&nbsp;𝐅 then 𝐅 is selected,
so assuming 𝑄 is a Boolean value,
we can simplify this definition to
∨𝑃𝑄&nbsp;≡&nbsp;𝑃𝐓𝑄.
Notice also that, if 𝑃 is a Boolean value
and selects the 𝐓 here,
then 𝑃 must have been true;
in other words, this simplifies further to
∨𝑃𝑄&nbsp;≡&nbsp;𝑃𝑃𝑄.
</p>
<p>
Doing β-reduction in reverse,
we can &ldquo;unapply&rdquo; the function one argument at a time.
This is called β-abstraction:
If ∨𝑃𝑄&nbsp;≡&nbsp;𝑃𝑃𝑄,
then ∨𝑃𝑄&nbsp;≡&nbsp;(λ𝑞.𝑃𝑃𝑞)𝑄.
In other words,
∨𝑃&nbsp;≡&nbsp;λ𝑞.𝑃𝑃𝑞.
After another round of β-abstraction,
given ∨𝑃&nbsp;≡&nbsp;λ𝑞.𝑃𝑃𝑞 we derive
∨𝑃&nbsp;≡&nbsp;(λ𝑝.λ𝑞.𝑝𝑝𝑞)𝑃.
In other words, ∨&nbsp;≡&nbsp;λ𝑝.λ𝑞.𝑝𝑝𝑞.
Whenever we see a wrapped application λ𝑥.𝐸𝑥,
where this 𝑥 does not appear in 𝐸,
we can apply a rule called η-reduction
to transform this into just 𝐸.
So ∨&nbsp;≡&nbsp;λ𝑝.𝑝𝑝.
</p>
<p>Similarly, AND (denoted ∧) can be defined as
∧&nbsp;≡&nbsp;λ𝑝.λ𝑞.𝑝𝑞𝑝.
If the first argument is false,
it should select something falsey, which it itself is.
So it can select itself!
But if it is true, then the outcome depends on the second operand:
the outcome is true if and only if that second operand is true,
so the second operand itself is the right thing to return.
</p>
<p>Finally, NOT (denoted ¬) returns false if the operand is true
and returns true if the operand is false:
¬&nbsp;≡&nbsp;λ𝑝.𝑝𝐅𝐓.
</p>
<p>Just like with circuits,
more complex operations can be built by composing these simple pieces.
For instance, the exclusive-or operation (XOR, denoted ⊕)
is defined such that
⊕&nbsp;≡&nbsp;λ𝑝.λ𝑞.∧(∨𝑝𝑞)(¬(∧𝑝𝑞));
the first operand is true
or the second is true,
but not both.
Alternatively:
⊕&nbsp;≡&nbsp;λ𝑝.λ𝑞.𝑝(¬𝑞)𝑞.
</p>
<table>
<thead><tr><th>Operation</th><th>Expression</th></tr></thead>
<tbody>
<tr>
 <td>𝐓</td><td>λ𝑥.λ𝑦.𝑥</td>
</tr>
<tr>
 <td>𝐅</td><td>λ𝑥.λ𝑦.𝑦</td>
</tr>
<tr>
 <td>¬</td><td>λ𝑝.𝑝𝐅𝐓</td>
</tr>
<tr>
 <td>∨</td><td>λ𝑝.𝑝𝑝</td>
</tr>
<tr>
 <td>∧</td><td>λ𝑝.λ𝑞.𝑝𝑞𝑝</td>
</tr>
<tr>
 <td>⊕</td><td>λ𝑝.λ𝑞.𝑝(¬𝑞)𝑞</td>
</tr>
</tbody>
</table>

<h3 id="natural-numbers"><a href="#natural-numbers"
>Natural Numbers</a></h3>
<p>Just as Booleans values were represented as functions
based on their use in if-then-else constructions,
so too are natural numbers represented based on their use.
What is, say, three?
In the λ-calculus,
threeness is doing something thrice.
A natural number 𝑛 is a function
which takes as its argument a function <i>f</i>
and returns 𝑓 composed with itself
for a total of 𝑛 applications.
So 𝟑&nbsp;≡&nbsp;λ𝑓.λ𝑥.𝑓(𝑓(𝑓𝑥)).
</p>
<p>Those familiar with Peano numbers
know that it suffices to define a zero and a successor function.
The result of applying a function zero times to an argument 𝑥
is just 𝑥 itself,
so 𝟎&nbsp;≡&nbsp;λ𝑓.λ𝑥.𝑥.
This should look familiar:
𝟎 takes two arguments and returns the second.
In other words, 𝟎&nbsp;≡&nbsp;𝐅.
The successor function takes a number and adds one to it,
applying the function one more time.
𝐒&nbsp;≡&nbsp;λ𝑛.λ𝑓.λ𝑥.𝑓(𝑛𝑓𝑥).
</p>
<p>We want 𝟏 to be the identity function
such that 𝟏𝑓𝑥&nbsp;≡&nbsp;𝑓𝑥.
Also, 𝟏&nbsp;≡&nbsp;𝐒𝟎.
Check:
𝐒𝟎&nbsp;≡&nbsp;(λ𝑛.λ𝑓.λ𝑥.𝑓(𝑛𝑓𝑥))𝟎
≡&nbsp;λ𝑓.λ𝑥.𝑓(𝟎𝑓𝑥)
≡&nbsp;λ𝑓.λ𝑥.𝑓𝑥
≡&nbsp;λ𝑓.𝑓,
the identity function, as desired.
</p>
<p>The successor function 𝐒 adds one to its first argument.
To add 𝑚 is to apply the successor function 𝑚 times.
But repeated application is exactly what these numbers represent!
The sum of 𝑚 and 𝑛 is simply 𝑚𝐒𝑛.
Define addition in exactly that way:
+&nbsp;≡&nbsp;λ𝑚.λ𝑛.𝑚𝐒𝑛.
By η-reduction,
+&nbsp;≡&nbsp;λ𝑚.𝑚𝐒.
And multiplication of 𝑚 by 𝑛
is simply to add 𝑚 copies of 𝑛:
5×3&nbsp;≡&nbsp;3+3+3+3+3.
That is, ×&nbsp;≡&nbsp;λ𝑚.λ𝑛.𝑚(𝑛𝐒)𝟎.
As a simpler alternative,
×&nbsp;≡&nbsp;λ𝑚.λ𝑛.λ𝑓.𝑚(𝑛𝑓).
</p>
<p>Tying in to the previous section,
sometimes one wants to query whether a number
satisfies some property.
One simple property is whether the number is zero.
In order to do this,
we need a function that takes an argument and returns false:
λ𝑥.𝐅.
If this function is applied one or more times
to an argument, the result is false.
But if it is applied zero times to an argument 𝑥,
then the result is 𝑥 itself.
Define 𝐙&nbsp;≡&nbsp;λ𝑛.𝑛(λ𝑥.𝐅)𝐓.
Then 𝐙𝟎&nbsp;≡&nbsp;𝟎(λ𝑥.𝐅)𝐓&nbsp;≡&nbsp;𝐓,
but 𝐙𝟐&nbsp;≡&nbsp;𝟐(λ𝑥.𝐅)𝐓
≡&nbsp;(λ𝑓.λ𝑥.𝑓(𝑓𝑥))(λ𝑥.𝐅)𝐓
≡&nbsp;(λ𝑥.(λ𝑥.𝐅)((λ𝑥.𝐅)𝑥))𝐓
≡&nbsp;(λ𝑥.𝐅)((λ𝑥.𝐅)𝐓)&nbsp;≡&nbsp;𝐅.
Recall how the Boolean values are defined;
λ𝑥.𝐅 is simply 𝐓𝐅.
So, 𝐙&nbsp;≡&nbsp;λ𝑛.𝑛(𝐓𝐅)𝐓.
</p>
<p>To determine whether two arbitrary numbers are equal
is more difficult.
There is no built-in comparison function,
no equality operator that we can leverage.
Instead of directly defining equality,
it is easier to first define inequality, ≤,
and to derive equality from that.
We begin by defining a clamped predecessor function 𝐏.
If 𝑥 is zero then 𝐏𝑥 is also zero,
otherwise it is 𝑥&minus;1.
In order to do <em>this</em>,
we introduce a representation of pairs.
Then we can define a function
𝑓(𝑎,𝑏)&nbsp;≡&nbsp;(𝑎+1,𝑎)
such that 𝑓(0,0)&nbsp;≡&nbsp;(1,0),
𝑓(𝑓(0,0))&nbsp;≡&nbsp;𝑓(1,0)&nbsp;≡&nbsp;(2,1),
and so on.
Then the result of 𝑛 applications of 𝑓 to (0,0)
will contain 𝑛&minus;1 in its second component.
</p>
<p>The pair (𝑎,𝑏) can be represented by the function
λ𝑓.𝑓𝑎𝑏.
Applying a select-first function yields 𝑎,
and applying a select-second function yields 𝑏.
We have those, they are 𝐓 and 𝐅, respectively.
Our partial-predecessor function is then
λ𝑝.λ𝑓.𝑓(𝐒(𝑝𝐓))(𝑝𝐓).
Take a pair 𝑝&nbsp;≡&nbsp;(𝑎,𝑏)
and return a new pair whose first component is 𝑎+1
and whose second component is just 𝑎.
Then 𝐏&nbsp;≡&nbsp;λ𝑛.𝑛(λ𝑝.λ𝑓.𝑓(𝐒(𝑝𝐓))(𝑝𝐓))(λ𝑓.𝑓𝟎𝟎)𝐅.
</p>
<p>With that in place, we have clamped subtraction,
sometimes called &ldquo;monus&rdquo;.
The difference 𝑥∸𝑦
is 𝑦 iterations of the predecessor function to 𝑥:
∸&nbsp;≡&nbsp;λ𝑥.λ𝑦.𝑦𝐏𝑥.
As 𝐏𝟎&nbsp;≡&nbsp;𝟎,
we have that ∸𝑥𝑦 is zero
if and only if 𝑥&nbsp;≤&nbsp;𝑦.
Define ≤&nbsp;≡&nbsp;λ𝑥.λ𝑦.𝐙(∸𝑥𝑦).
Two natural numbers are equal if each is less than or equal to the other;
define equality, =, as
λ𝑥.λ𝑦.∧(≤𝑥𝑦)(≤𝑦𝑥).
The other possibilities can easily be defined in terms of these.
</p>
<table>
<thead><tr><th>Object</th><th>Expression</th></tr></thead>
<tbody>
<tr>
 <td>𝟎</td>
 <td>λ𝑥.λ𝑦.𝑦</td>
</tr>
<tr>
 <td>𝐒 (successor)</td>
 <td>λ𝑛.λ𝑓.λ𝑥.𝑓(𝑛𝑓𝑥)</td>
</tr>
<tr>
 <td>𝐏 (clamped predecessor)</td>
 <td>λ𝑛.𝑛(λ𝑝.λ𝑓.𝑓(𝐒(𝑝𝐓))(𝑝𝐓))(λ𝑓.𝑓𝟎𝟎)𝐅</td>
</tr>
<tr>
 <td>𝐙 (zero?)</td>
 <td>λ𝑛.𝑛(𝐓𝐅)𝐓</td>
</tr>
<tr>
 <td>+</td>
 <td>λ𝑚.𝑚𝐒</td>
</tr>
<tr>
 <td>∸ (&ldquo;monus&rdquo;)</td>
 <td>λ𝑚.λ𝑛.𝑛𝐏𝑚</td>
</tr>
<tr>
 <td>×</td>
 <td>λ𝑚.λ𝑛.λ𝑓.𝑚(𝑛𝑓)</td>
</tr>
<tr>
 <td>≤</td>
 <td>λ𝑚.λ𝑛.𝐙(∸𝑚𝑛)</td>
</tr>
<tr>
 <td>=</td>
 <td>λ𝑚.λ𝑛.∧(≤𝑚𝑛)(≤𝑛𝑚)</td>
</tr>
</tbody>
</table>

<h3 id="integers"><a href="#integers">Integers</a></h3>
<p>So far, we have the natural numbers, the nonnegative numbers.
We also have pairs and Boolean values,
so one way to represent all integers would be to encode a pair
containing a sign bit and a magnitude.
Those familiar with foundational set theory, however,
may be aware of a different representation,
which does not use Boolean values.
Instead, integers are represented by pairs,
where (𝑥,𝑦) represents
the integer 𝑥&minus;𝑦.
Each possible integer has infinitely many representative pairs,
but this representation is easier to work with.
</p>
<p>For instance, addition is pointwise.
The pair (𝑥,𝑦) represents 𝑥&minus;𝑦,
and (𝑎,𝑏) represents 𝑎&minus;𝑏,
and (𝑥+𝑎,𝑦+𝑏)
represents
(𝑥+𝑎)&minus;(𝑦+𝑏)
≡&nbsp;𝑥+𝑎&minus;𝑦&minus;𝑏
≡&nbsp;(𝑥&minus;𝑦)+(𝑎&minus;𝑏).
Recall that a pair selects a function and applies it
with its two components as arguments, in order,
and that 𝐓 selects the first and 𝐅 selects the second.
Define +<sub>Z</sub>&nbsp;≡&nbsp;λ𝑝.λ𝑟.λ𝑓.𝑓(+(𝑝𝐓)(𝑟𝐓))(+(𝑝𝐅)(𝑟𝐅));
take two pairs 𝑝 and 𝑟 representing integers,
then return the pair obtained by adding each component separately.
</p>
<p>If (𝑥,𝑦) represents 𝑥&minus;𝑦,
then
&minus;(𝑥&minus;𝑦)&nbsp;≡&nbsp;𝑦&minus;𝑥
is represented by (𝑦,𝑥).
Negation is to flip the pair:
𝐍&nbsp;≡&nbsp;λ𝑝.λ𝑓.𝑓(𝑝𝐅)(𝑝𝐓).
To subtract two integers, we can define
&minus;<sub>Z</sub>&nbsp;≡&nbsp;λ𝑚.λ𝑛.+<sub>Z</sub>𝑚(𝐍𝑛).
After expansion and simplification,
&minus;<sub>Z</sub>&nbsp;≡&nbsp;λ𝑝.λ𝑟.λ𝑓.𝑓(+(𝑝𝐓)(𝑟𝐅))(+(𝑝𝐅)(𝑟𝐓)).
</p>
<p>Recall that (∸𝑥𝑦) represents
max(𝑥&minus;𝑦,0).
If 𝑥≤𝑦, this is 0,
but if 𝑥≥𝑦, this is 𝑥&minus;𝑦.
By trichotomy,
+(∸𝑥𝑦)(∸𝑦𝑥)
is the absolute value of 𝑥&minus;𝑦.
Thus, to obtain the absolute value of an integer
as a natural number, we can define
𝐀&nbsp;≡&nbsp;λ𝑥.+(𝑥∸)(𝑥(λ𝑎.λ𝑏.𝑎𝐏𝑏))&nbsp;≡&nbsp;λ𝑥.+(𝑥∸)(𝑥(λ𝑎.𝑎𝐏)).
To test whether an integer is zero
is to test whether its absolute value is zero,
so 𝐙<sub>Z</sub>&nbsp;≡&nbsp;λ𝑛.𝐙(𝐀𝑛).
</p>
<p>Finally, to multiply integers,
note that the distributive property holds:
𝑘⋅(𝑥&minus;𝑦)&nbsp;≡&nbsp;𝑘⋅𝑥&minus;𝑘⋅𝑦.
So we want to multiply each component of one pair
by the absolute value of the other pair,
and negate the result if necessary.
Define
×<sub>Z</sub>&nbsp;≡&nbsp;λ𝑚.λ𝑛.𝑚≤𝐍(𝟎𝐍)(λ𝑓.(×(𝐀𝑚)(𝑛𝐓))(×(𝐀𝑚)(𝑛𝐅))).
</p>
<table>
<thead><tr>
 <th>Operation</th><th>Expression</th>
</tr></thead>
<tbody>
<tr>
 <td>𝐀 (absolute value)</td>
 <td>λ𝑛.+(𝑛∸)(𝑛(λ𝑎.𝑎𝐏))</td>
</tr>
<tr>
 <td>𝐙<sub>Z</sub></td>
 <td>λ𝑛.𝐙(𝐀𝑛)</td>
</tr>
<tr>
 <td>+<sub>Z</sub></td>
 <td>λ𝑚.λ𝑛.λ𝑓.𝑓(+(𝑚𝐓)(𝑛𝐓))(+(𝑚𝐅)(𝑛𝐅))</td>
</tr>
<tr>
 <td>&minus;<sub>Z</sub></td>
 <td>λ𝑚.λ𝑛.λ𝑓.𝑓(+(𝑚𝐓)(𝑛𝐅))(+(𝑚𝐅)(𝑛𝐓))</td>
</tr>
<tr>
 <td>×<sub>Z</sub></td>
 <td>λ𝑚.λ𝑛.𝑚≤𝐍(𝟎𝐍)(λ𝑓.(×(𝐀𝑚)(𝑛𝐓))(×(𝐀𝑚)(𝑛𝐅)))</td>
</tr>
</tbody>
</table>

<h3 id="lists"><a href="#lists">Lists</a></h3>
<p>With numbers available,
one might naturally want to represent a list of numbers.
Recall that in defining integers
we used pairs, represented by functions
that take (essentially) two-argument functions as input.
Given a pair 𝑝 of natural numbers,
𝑝𝐓 is the first,
𝑝𝐅 is the second,
𝑝+ is their sum, and so on.
To represent a list,
we might consider a similar sort of configuration:
a list 𝐿 is a function which takes as its arguments
a binary operation 𝑓 and a default value 𝑥.
If the list is empty, then application yields the default value,
𝐿𝑓𝑥&nbsp;≡&nbsp;𝑥.
Otherwise, the list has a head ℎ and a tail 𝑡,
and the application yields
𝐿𝑓𝑥&nbsp;≡&nbsp;𝑓ℎ(𝑡𝑓𝑥).
</p>
<p>This gives us exactly the information that we need
in order to construct something akin to a linked list.
Like zero and falsity,
the empty list ignores its first argument and returns its second:
∅&nbsp;≡&nbsp;𝟎.
Then to cons a head ℎ onto a tail 𝑡,
we can use
𝐂&nbsp;≡&nbsp;λℎ.λ𝑡.λ𝑓.λ𝑥.𝑓ℎ(𝑡𝑓𝑥).
</p>
<p>A function which takes a list of integers
and returns their sum is
Σ&nbsp;≡&nbsp;λ𝑎.𝑎+<sub>Z</sub>(λ𝑓.𝑓𝟎𝟎).
The product is
Π&nbsp;≡&nbsp;λ𝑎.𝑎×<sub>Z</sub>(λ𝑓.𝑓(𝐒𝟎)𝟎).
To get the length, the function should ignore the head
and return the successor of the result,
and the default value should be the natural number zero:
𝐋&nbsp;≡&nbsp;λ𝑎.𝑎(λℎ.𝐒)𝟎.
To extract the head, or return 𝐅 in the case of an empty list,
define 𝐇&nbsp;≡&nbsp;λ𝑎.𝑎𝐓𝐅.
Finally, to extract the tail, we use a technique similar to that
used for finding the predecessor of a natural number.
The initial value is a pair consisting of two copies of the empty set.
The binary operation takes the head ℎ of the list
and such a pair (𝑥,𝑦),
and returns (𝐂ℎ𝑥,𝑥).
The tail in the end is the second component:
↓&nbsp;≡&nbsp;λ𝑎.𝑎(λℎ.λ𝑝.λ𝑓.𝑓(𝐂ℎ(𝑝𝐓))(𝑝𝐓))(λ𝑓.𝑓∅∅)𝐅.
This, with repeated application gives an indexing function:
drop 𝑛 elements and take the head:
@&nbsp;≡&nbsp;λ𝑎.λ𝑛.𝐇(𝑛↓𝑎).
</p>
<table>
<thead><tr><th>Operation</th><th>Expression</th></tr></thead>
<tbody>
<tr>
 <td>∅ (empty)</td>
 <td>𝟎</td>
</tr>
<tr>
 <td>𝐂 (cons)</td>
 <td>λℎ.λ𝑡.λ𝑓.λ𝑥.𝑓ℎ(𝑡𝑓𝑥)</td>
</tr>
<tr>
 <td>Σ (sum)</td>
 <td>λ𝑎.𝑎+<sub>Z</sub>(λ𝑓.𝑓𝟎𝟎)</td>
</tr>
<tr>
 <td>Π (product)</td>
 <td>λ𝑎.𝑎×<sub>Z</sub>(λ𝑓.𝑓(𝐒𝟎)𝟎)</td>
</tr>
<tr>
 <td>𝐋 (length)</td>
 <td>λ𝑎.𝑎(λℎ.𝐒)𝟎</td>
</tr>
<tr>
 <td>𝐇 (head)</td>
 <td>λ𝑎.𝑎𝐓𝐅</td>
</tr>
<tr>
 <td>↓ (tail)</td>
 <td>λ𝑎.𝑎(λℎ.λ𝑝.λ𝑓.𝑓(𝐂ℎ(𝑝𝐓))(𝑝𝐓))(λ𝑓.𝑓∅∅)𝐅</td>
</tr>
<tr>
 <td>@ (index)</td>
 <td>λ𝑎.λ𝑛.𝐇(𝑛↓𝑎)</td>
</tr>
</tbody>
</table>

<h3 id="recursion"><a href="#recursion">Recursion</a></h3>
<p>To this point, none of our functions have been recursive.
This is both because we have not needed such power
and because the λ-calculus does not support recursion at all.
Suppose we want to find the sum of the natural numbers
up to and including 𝑛.
Now, of course, we know that the result should be
𝑛(𝑛+1)/2,
but, alas, we have yet to define a division function.
Rather than incorporate division,
let us consider how we might compute this result.
</p>
<p>One method is to create a function φ that will map a pair
(𝑥,𝑎) to a new pair
(𝑥+1,𝑎+𝑥+1).
Applying this function thrice to (0,0) proceeds as follows:
(0,0) becomes (1,1), which becomes (2,3), which finally becomes (3,6).
In general, upon 𝑛 applications,
the first component is 𝑛
and the second component is the sum of the natural numbers
up to and including 𝑛.
Because numbers in the λ-calculus represent repeated application,
this satisfies the requirement.
Define φ&nbsp;≡&nbsp;λ𝑥.λ𝑓.𝑓(𝐒(𝑥𝐓))(+(𝐒(𝑥𝐓))(𝑥𝐅)).
Then define Δ&nbsp;≡&nbsp;λ𝑛.𝑛φ(λ𝑓.𝑓𝟎𝟎)𝐅
to compute the desired sum.
This is essentially a functionalization
of the iterative solution to the problem.
</p>
<p>Another high-level approach would be to use a recursive function:
Δ(𝑛) is 0 if 𝑛 is 0,
else it is 𝑛+Δ(𝑛&minus;1).
But we cannot say
[<em>invalid:</em> Δ&nbsp;≡&nbsp;λ𝑛.𝐙𝑛𝟎(+𝑛(Δ(𝐏𝑛)))],
because this kind of self-reference
creates an infinitely long formula.
What we can do is supply as an argument
the function to be used as the &ldquo;recursive&rdquo; call:
Δ&nbsp;≡&nbsp;λ𝑓.λ𝑛.𝐙𝑛𝟎(+𝑛(𝑓(𝐏𝑛))).
Then, as long we provide a sufficiently large stack of Δ,
we can recursively compute the solution:
Δ(Δ(Δ(ΔΔ)))𝟑&nbsp;≡&nbsp;(+𝟑(Δ(Δ(ΔΔ))𝟐))
≡&nbsp;(+𝟑(+𝟐(Δ(ΔΔ)𝟏)))
≡&nbsp;(+𝟑(+𝟐(+𝟏(ΔΔ𝟎))))
≡&nbsp;(+𝟑(+𝟐(+𝟏(𝟎))))
≡&nbsp;𝟔.
Then what we want is some way
to get a sufficiently tall stack of Δ,
no matter the parameter.
</p>
<p>Enter the 𝐘 combinator,
defined such that
𝐘𝑓&nbsp;≡&nbsp;𝑓(𝐘𝑓).
We cannot define it this way, because this uses recursion.
Instead, we define 𝐘
such that it accepts a function as an argument,
then reconstructs itself as an argument to that function:
𝐘&nbsp;≡&nbsp;λ𝑓.(λ𝑥.𝑓(𝑥𝑥))(λ𝑥.𝑓(𝑥𝑥)).
Then applying this to a function 𝑔 yields
𝐘𝑔&nbsp;≡&nbsp;(λ𝑓.(λ𝑥.𝑓(𝑥𝑥))(λ𝑥.𝑓(𝑥𝑥)))𝑔
≡&nbsp;(λ𝑥.𝑔(𝑥𝑥))(λ𝑥.𝑔(𝑥𝑥))
≡&nbsp;𝑔((λ𝑥.𝑔(𝑥𝑥))(λ𝑥.𝑔(𝑥𝑥)))
≡&nbsp;𝑔(𝐘𝑔).
Now, we have
𝐘Δ𝟑&nbsp;≡&nbsp;Δ(𝐘Δ)𝟑
≡&nbsp;(+𝟑(𝐘Δ𝟐))
≡&nbsp;(+𝟑(Δ(𝐘Δ)𝟐))
≡&nbsp;(+𝟑(+𝟐(𝐘Δ𝟏)))
≡&nbsp;(+𝟑(+𝟐(Δ(𝐘Δ)𝟏)))
≡&nbsp;(+𝟑(+𝟐(+𝟏(𝐘Δ𝟎))))
≡&nbsp;(+𝟑(+𝟐(+𝟏(Δ(𝐘Δ)𝟎))))
≡&nbsp;(+𝟑(+𝟐(+𝟏(𝟎))))
≡&nbsp;𝟔, as desired.
We need not concern ourselves with providing an appropriate
number of Δ, because 𝐘Δ always produces another.
</p>

<h3 id="directions"><a href="#directions">Directions</a></h3>
<p>This post sampled a small collection of common
objects and data structures
to serve as an introduction to the λ-calculus
and the functional approach to computation.
Unlike a Turing machine or a personal computer,
there is no notion of a memory layout,
no restriction to a linear pattern of cells.
Even so, structuring data requires careful thought.
Using the provided structures and applications as a guide,
consider trying these additional challenges.
For how many of them is 𝐘 necessary?
</p>
<ul>
<li>Define the missing inequalities on natural numbers.</li>
<li>Define equality and inequalities on integers.</li>
<li>Define the factorial function on natural numbers,
where the factorial of zero is one,
and the factorial of any 𝑛 greater than zero
is the product of 𝑛 and the factorial of 𝑛&minus;1.</li>
<li>Define the integer-division of natural numbers or integers.</li>
<li>Construct the rational numbers along with appropriate
  addition, subtraction, multiplication and division.</li>
<li>Implement natural number exponents
  on natural numbers or integers.</li>
<li>Implement integer exponents on rational numbers.</li>
<li>Implement some representation of a binary tree.</li>
</ul>
</article>
<footer>
<p><a
     id="cy-effective-orcid-url"
     class="underline"
     href="https://orcid.org/0000-0002-7056-5950"
     target="orcid.widget"
     rel="me noopener noreferrer"
     style="vertical-align: top"
    ><img
      src="https://orcid.org/sites/default/files/images/orcid_16x16.png"
      style="width: 1em"
      alt="ORCID iD icon">
    https://orcid.org/0000-0002-7056-5950
  </a></p>
</footer>
</div>
</div>
</body>
</html>
